#!/usr/bin/env -S uv run python
"""
Identify Dead Files in Mallku Codebase
======================================

64th Artisan - Finding what's truly dead to make room for life

This analyzes only Mallku's actual source files, not dependencies.
"""

import ast
from pathlib import Path


def is_dead_file(file_path: Path) -> tuple[bool, str]:
    """
    Determine if a Python file is dead (stub/empty).
    Returns (is_dead, reason).
    """
    try:
        content = file_path.read_text()

        # Empty or nearly empty files
        if len(content.strip()) < 10:
            return True, "empty"

        # Parse the AST
        tree = ast.parse(content)

        # Check if it's just __init__.py with no real content
        if file_path.name == "__init__.py":
            # Look for anything beyond imports
            has_content = False
            for node in tree.body:
                if not isinstance(node, ast.Import | ast.ImportFrom):
                    # Check if it's __all__ definition
                    if isinstance(node, ast.Assign) and any(
                        target.id == "__all__" for target in node.targets if hasattr(target, "id")
                    ):
                        continue
                    has_content = True
                    break
            if not has_content:
                return True, "empty __init__"

        # Count real definitions
        real_definitions = 0
        stub_definitions = 0

        for node in ast.walk(tree):
            if isinstance(node, ast.FunctionDef | ast.AsyncFunctionDef | ast.ClassDef):
                # Check if it's a stub (only has pass or ...)
                if len(node.body) == 1:
                    stmt = node.body[0]
                    if isinstance(stmt, ast.Pass):
                        stub_definitions += 1
                    elif isinstance(stmt, ast.Expr) and isinstance(stmt.value, ast.Constant):
                        if stmt.value.value == ...:  # Ellipsis
                            stub_definitions += 1
                    else:
                        real_definitions += 1
                else:
                    real_definitions += 1

        # File is dead if it has only stubs or no definitions
        if real_definitions == 0 and stub_definitions > 0:
            return True, f"only stubs ({stub_definitions})"
        elif real_definitions == 0 and stub_definitions == 0:
            # Check if it has any substantial code
            non_import_nodes = [
                node for node in tree.body if not isinstance(node, ast.Import | ast.ImportFrom)
            ]
            if len(non_import_nodes) == 0:
                return True, "only imports"

        return False, "has real code"

    except Exception as e:
        return False, f"parse error: {e}"


def analyze_mallku_dead_files():
    """Find all dead files in Mallku's actual codebase"""

    print("🔍 Analyzing Mallku Source for Dead Files")
    print("=" * 60)

    # Directories to analyze
    source_dirs = ["src", "tests", "scripts"]

    dead_files = []
    alive_files = []

    for source_dir in source_dirs:
        dir_path = Path(source_dir)
        if not dir_path.exists():
            continue

        for py_file in dir_path.rglob("*.py"):
            # Skip pycache
            if "__pycache__" in str(py_file):
                continue

            is_dead, reason = is_dead_file(py_file)

            if is_dead:
                dead_files.append((py_file, reason))
            else:
                alive_files.append(py_file)

    # Report findings
    total_files = len(dead_files) + len(alive_files)

    print(f"\nTotal Python files analyzed: {total_files}")
    print(f"Living files: {len(alive_files)} ({len(alive_files) / total_files * 100:.1f}%)")
    print(f"Dead files: {len(dead_files)} ({len(dead_files) / total_files * 100:.1f}%)")

    if dead_files:
        print("\n\n📋 DEAD FILES TO ELIMINATE:")
        print("=" * 60)

        # Group by reason
        by_reason = {}
        for file_path, reason in dead_files:
            if reason not in by_reason:
                by_reason[reason] = []
            by_reason[reason].append(file_path)

        for reason, files in sorted(by_reason.items()):
            print(f"\n### {reason} ({len(files)} files)")
            for f in sorted(files)[:20]:  # Show first 20
                print(f"  - {f}")
            if len(files) > 20:
                print(f"  ... and {len(files) - 20} more")

    # Save manifest
    manifest_path = Path("dead_files_manifest.txt")
    with open(manifest_path, "w") as f:
        f.write("# Dead Files in Mallku Codebase\n")
        f.write("# Generated by 64th Artisan\n")
        f.write(f"# Total: {len(dead_files)} files\n\n")

        for file_path, reason in sorted(dead_files):
            f.write(f"{file_path} # {reason}\n")

    print(f"\n\n📄 Manifest saved to: {manifest_path}")
    print(f"\n💀 These {len(dead_files)} files can be eliminated to reduce context overhead")

    return dead_files


if __name__ == "__main__":
    dead_files = analyze_mallku_dead_files()
