#!/usr/bin/env -S uv run python
"""
Find Truly Dead Files and Directories
=====================================

64th Artisan - Distinguishing the sleeping from the dead
"""

from pathlib import Path


def is_directory_dead(dir_path: Path) -> bool:
    """Check if a directory contains only empty __init__.py"""
    py_files = list(dir_path.glob("*.py"))

    # No Python files at all
    if not py_files:
        return True

    # Only has __init__.py
    return (
        len(py_files) == 1 and py_files[0].name == "__init__.py" and py_files[0].stat().st_size < 10
    )


def find_dead_elements():
    """Find truly dead files and empty directories"""

    print("üîç Finding Truly Dead Elements in Mallku")
    print("=" * 60)

    dead_files = []
    alive_but_empty_init = []
    dead_directories = []

    # Check all Python files
    for py_file in Path(".").rglob("*.py"):
        # Skip virtual env and pycache
        if any(part in str(py_file) for part in [".venv", "venv", "__pycache__", ".git"]):
            continue

        # Check file size
        if py_file.stat().st_size < 10:
            # Check if directory has other files
            parent = py_file.parent
            other_files = [f for f in parent.glob("*.py") if f != py_file]

            if other_files:
                # Directory has other Python files, just init is empty
                if py_file.name == "__init__.py":
                    alive_but_empty_init.append(py_file)
                else:
                    dead_files.append(py_file)
            else:
                # Only file in directory
                dead_files.append(py_file)

    # Check for completely empty directories
    for src_dir in ["src/mallku", "tests"]:
        for path in Path(src_dir).rglob("*"):
            if path.is_dir():
                # Check if directory has any non-pycache content
                contents = list(path.iterdir())
                real_contents = [c for c in contents if "__pycache__" not in str(c)]

                if (
                    not real_contents
                    or len(real_contents) == 1
                    and real_contents[0].name == "__init__.py"
                    and real_contents[0].stat().st_size < 10
                    and is_directory_dead(path)
                ):
                    dead_directories.append(path)

    # Report findings
    print("\nüìä ANALYSIS RESULTS:")
    print(f"Truly dead files: {len(dead_files)}")
    print(f"Alive packages with empty __init__.py: {len(alive_but_empty_init)}")
    print(f"Dead directories: {len(dead_directories)}")

    if dead_files:
        print(f"\n\nüíÄ TRULY DEAD FILES ({len(dead_files)}):")
        for f in sorted(dead_files):
            print(f"  - {f}")

    if alive_but_empty_init:
        print(f"\n\nüì¶ ALIVE PACKAGES WITH EMPTY __init__.py ({len(alive_but_empty_init)}):")
        for f in sorted(alive_but_empty_init)[:10]:
            print(f"  - {f}")
        if len(alive_but_empty_init) > 10:
            print(f"  ... and {len(alive_but_empty_init) - 10} more")
        print("\n  These should get proper __init__.py files, not deletion!")

    if dead_directories:
        print(f"\n\nüóëÔ∏è  DEAD DIRECTORIES ({len(dead_directories)}):")
        for d in sorted(dead_directories):
            print(f"  - {d}/")

    # Create action plan
    print("\n\nüìã RECOMMENDED ACTIONS:")
    print("=" * 60)

    total_deletions = len(dead_files) + len(dead_directories)
    print(f"1. Delete {total_deletions} truly dead elements")
    print(f"2. Add proper __init__.py to {len(alive_but_empty_init)} living packages")

    # Save manifest of what to delete
    with open("truly_dead_manifest.txt", "w") as f:
        f.write("# Truly Dead Elements to Remove\n")
        f.write("# Generated by 64th Artisan\n\n")

        f.write("# Dead Files\n")
        for df in sorted(dead_files):
            f.write(f"rm {df}\n")

        f.write("\n# Dead Directories\n")
        for dd in sorted(dead_directories):
            f.write(f"rmdir {dd}\n")

    print("\nüìÑ Deletion commands saved to: truly_dead_manifest.txt")

    return dead_files, dead_directories, alive_but_empty_init


if __name__ == "__main__":
    find_dead_elements()
