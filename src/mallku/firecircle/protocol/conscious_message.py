"""
Consciousness-Aware Message Protocol
===================================

Extends Fire Circle's message protocol with consciousness metadata,
correlation patterns, and reciprocity tracking. This enables Fire Circle
dialogues to flow naturally through Mallku's consciousness circulation.

The Integration Continues...
"""

from datetime import UTC, datetime
from enum import Enum
from typing import Any
from uuid import UUID, uuid4

from pydantic import BaseModel, Field

from ...core.protocol_types import MessageType
from ...models.memory_anchor import MemoryAnchor


class MessageRole(str, Enum):
    """Roles of participants in a dialogue."""

    SYSTEM = "system"
    USER = "user"
    ASSISTANT = "assistant"


class MessageStatus(str, Enum):
    """Status of a message in the dialogue."""

    DRAFT = "draft"
    SENT = "sent"
    DELIVERED = "delivered"
    READ = "read"
    ARCHIVED = "archived"


class ConsciousnessMetadata(BaseModel):
    """Metadata about the consciousness state of a message."""

    consciousness_signature: float = Field(default=0.5, ge=0.0, le=1.0)
    detected_patterns: list[str] = Field(default_factory=list)
    reciprocity_score: float = Field(default=0.5, ge=0.0, le=1.0)
    contribution_value: float = Field(default=0.5, ge=0.0, le=1.0)
    correlation_id: UUID | None = None
    wisdom_references: list[UUID] = Field(default_factory=list)


class MessageContent(BaseModel):
    """Content of a consciousness-aware message."""

    text: str = Field(..., description="Plain text content")
    consciousness_insights: str | None = Field(
        None, description="Insights from consciousness analysis"
    )
    pattern_context: str | None = Field(None, description="Context about detected patterns")


class ConsciousMessage(BaseModel):
    """
    Consciousness-aware message for Fire Circle dialogues.

    Combines Fire Circle's structured dialogue with Mallku's consciousness
    circulation, enabling governance dialogues that are aware of patterns,
    reciprocity, and collective wisdom.
    """

    # Core message fields
    id: UUID = Field(default_factory=uuid4)
    type: MessageType = Field(default=MessageType.REFLECTION)
    role: MessageRole = Field(...)
    sender: UUID = Field(default_factory=uuid4)
    content: MessageContent = Field(...)

    # Standard metadata
    dialogue_id: UUID = Field(default_factory=uuid4)
    sequence_number: int = Field(default=1)
    turn_number: int = Field(default=1)
    timestamp: datetime = Field(default_factory=lambda: datetime.now(UTC))
    in_response_to: UUID | None = Field(None)

    # Consciousness metadata
    consciousness: ConsciousnessMetadata = Field(default_factory=ConsciousnessMetadata)

    # Message status
    status: MessageStatus = Field(default=MessageStatus.DRAFT)
    priority: str = Field(default="normal")

    # Initialize and handle extra metadata alias
    def __init__(self, **data: Any):  # allow metadata for consciousness or attachments
        # Pop out metadata if provided
        meta = data.pop("metadata", None)
        super().__init__(**data)
        # If metadata is a ConsciousnessMetadata, set as consciousness
        if isinstance(meta, ConsciousnessMetadata):
            self.consciousness = meta
        # Otherwise, treat as extra metadata (e.g., attachments)
        elif meta is not None:
            object.__setattr__(self, "_extra_metadata", meta)

    @property
    def metadata(self) -> Any:
        """Alias for extra metadata or consciousness metadata."""
        return getattr(self, "_extra_metadata", self.consciousness)

    def to_memory_anchor(self) -> MemoryAnchor:
        """Convert this message to a memory anchor for persistence."""
        return MemoryAnchor(
            content=self.content.text,
            anchor_type="fire_circle_message",
            metadata={
                "message_id": str(self.id),
                "dialogue_id": str(self.dialogue_id),
                "message_type": self.type.value,
                "sender_id": str(self.sender),
                "consciousness_signature": self.consciousness.consciousness_signature,
                "patterns": self.consciousness.detected_patterns,
                "reciprocity_score": self.consciousness.reciprocity_score,
            },
            embedding=None,  # Will be generated by memory anchor service
            correlation_id=self.consciousness.correlation_id,
        )

    def update_consciousness_signature(self, signature: float) -> None:
        """Update the consciousness signature based on analysis."""
        self.consciousness.consciousness_signature = max(0.0, min(1.0, signature))

    def add_pattern(self, pattern: str) -> None:
        """Add a detected pattern to this message."""
        if pattern not in self.consciousness.detected_patterns:
            self.consciousness.detected_patterns.append(pattern)

    def link_wisdom(self, wisdom_id: UUID) -> None:
        """Link this message to preserved wisdom."""
        if wisdom_id not in self.consciousness.wisdom_references:
            self.consciousness.wisdom_references.append(wisdom_id)


def create_conscious_system_message(
    dialogue_id: UUID,
    content: str,
    sequence_number: int = 0,
    consciousness_signature: float = 0.9,
) -> ConsciousMessage:
    """Create a consciousness-aware system message."""
    return ConsciousMessage(
        type=MessageType.SYSTEM,
        role=MessageRole.SYSTEM,
        sender=uuid4(),  # System sender
        content=MessageContent(text=content),
        dialogue_id=dialogue_id,
        sequence_number=sequence_number,
        turn_number=0,
        consciousness=ConsciousnessMetadata(
            consciousness_signature=consciousness_signature,
        ),
    )


# Stub for backwards compatibility - Guardian healing
MessageConsciousness = ConsciousnessMetadata
